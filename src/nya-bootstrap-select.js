'use strict';

angular.module('nya.bootstrap.select',[])
  .directive('nyaSelectpicker', function ($parse) {

    // NG_OPTIONS_REGEXP copy from angular.js select directive
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    return {
      restrict: 'CA',
      scope: false,
      require: ['^ngModel', 'select'],

      link: function(scope, element, attrs, ctrls) {
        var optionsExp = attrs.ngOptions;
        var valuesFn, match;
        if(optionsExp && (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          valuesFn = $parse(match[7]);
        }
        var ngCtrl = ctrls[0];
        var selectCtrl = ctrls[1];
        // prevent selectDirective render an unknownOption.
        selectCtrl.renderUnknownOption = angular.noop;
        var optionArray = [];
        scope.$watch(function optionDOMWatch(){
          // check every option if has changed.
          var optionElements = $(element).find('option');

          //if the first option has no value and label or value an value of ?, this must be generated by ngOptions directive. Remove it.
          if(!optionElements.eq(0).html() && (optionElements.eq(0).attr('value') ==='?' || !optionElements.eq(0).attr('value'))) {
            optionElements.remove(':first');
          }

          if(optionElements.length !== optionArray.length) {
            optionArray = makeOptionArray(optionElements);
            buildSelector();
          } else {
            var hasChanged = false;
            optionElements.each(function(index, value){
              if(optionArray[index].text !== value.text || optionArray[index].value !== value.value) {
                hasChanged = true;

              }
            });
            if(hasChanged) {
              buildSelector();
            }
            optionArray = makeOptionArray(optionElements);
          }

        });

        ngCtrl.$render = function() {
          // model -> view
          var data = $(element).data('selectpicker');
          if(data) {
            if(!!valuesFn) {
              // transform value to index of options
              var collection = valuesFn(scope);
              if(angular.isArray(collection) && !angular.isArray(ngCtrl.$viewValue)) {
                var index = indexInArray(ngCtrl.$viewValue, collection);
                if(index > -1) {
                  $(element).val(index).selectpicker('render');
                }
              } else if(angular.isArray(collection) && angular.isArray(ngCtrl.$viewValue)) {
                var indexArray = [];
                for(var i = 0; i < ngCtrl.$viewValue.length; i++) {
                  var indexOfOptions = indexInArray(ngCtrl.$viewValue[i], collection);
                  if(indexOfOptions > -1) {
                    indexArray.push(indexOfOptions);
                  }
                }
                $(element).val(indexArray).selectpicker('render');
              } else if(!angular.isArray(collection) && !angular.isArray(ngCtrl.$viewValue)) {
                var key = keyOfObject(ngCtrl.$viewValue, collection);
                if(key) {
                  $(element).val(key).selectpicker('render');
                }
              } else if(!angular.isArray(collection) && angular.isArray(ngCtrl.$viewValue)) {
                var keyArray = [];
                for(var j = 0; j < ngCtrl.$viewValue.length; j++) {
                  var k = keyOfObject(ngCtrl.$viewValue[j], collection);
                  if(k) {
                    keyArray.push(k);
                  }
                }
                $(element).val(keyArray).selectpicker('render');
              }

            } else {
              $(element).val(ngCtrl.$viewValue).selectpicker('render');
            }
          }
        };

        function indexInArray(value, array) {
          for(var i = 0; i < array.length; i++) {
            if(angular.equals(value, array[i])) {
              return i;
            }
          }
          return -1;
        }

        function keyOfObject(value, object) {
          var key = null;
          angular.forEach(object, function(v, k) {
            if(angular.equals(v, value)) {
              key = k;
            }
          });
          return key;
        }

        function makeOptionArray(optionElements) {
          var optionArray = [];
          optionElements.each(function(index, childNode){
            optionArray.push({
              value: childNode.value,
              text: childNode.text
            });
          });
          return optionArray;
        }

        function buildSelector() {
          // build new selector. if previous select exists. remove previous data and DOM
          var oldSelectPicker = $(element).data('selectpicker');
          if(oldSelectPicker) {
            oldSelectPicker.$menu.parent().remove();
            oldSelectPicker.$newElement.remove();
            $(element).removeData('selectpicker');
          }
          $(element).selectpicker();
//          console.log(ngCtrl.$modelValue);
          $(element).val(ngCtrl.$modelValue).selectpicker('render');
        }

      }
    };
  });
